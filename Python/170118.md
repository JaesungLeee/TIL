# 파이썬 기본기 익히기 두번째 

## 1. 리스트 (List)

리스트(List) 자료형은 어떠한 데이터들의 선형적(Linear)인 모음을 표현 하는 방법들 중 하나 이다. 예를 들어 짝수들의 목록 인 `2, 6, 8, 12, 16, 22` 가 존재 할 경우 이러한 숫자의 표현을 파이썬에서 표현하면 아래와 같다. 

```py
evenNumbers = [2, 6, 8, 12, 16, 22]
```

자세히 보면 원소들을 대괄호인 `[, ]`로 감싸고 `,`쉼표 글자로 각 원소를 구분하고 있음을 확인 할 수 있다. 또한 리스트의 표현은 여러가지로 존재 할 수 있는데 그 예로 아래와 같이 표현할 수 있다. 

```py
list1 = []
list2 = [1, 2, 3]
list3 = ['kang', 'kim', 'park']
list4 = ['kim', 100, 0.15, 'lee']
list5 = [1, ['kim', 'jung', 'lee'], 2, 3]
```

1번째 리스트 처럼 원소가 존재하지 않는 리스트도 있으며 문자열이나 숫자, 다른 자료형을 가진 리스트도 존재 할 수 있다. 그리고 4번째 리스트 처럼 리스트 내에 다른 리스트를 존재 할 수 있다. 이는 리스트 내부에서는 어떠한 자료형을 모두 사용 할 수 있는 것 이다. 

## 1.1 리스트의 인덱스 처리  

연속된 문자의 목록으로 이루어진 문자열의 인덱스 처리 처럼, 어떠한 원소들의 모임인 리스트도 인덱스로 접근 할 수 있으며 이에 대해 편집 할 수 있는 기능들을 제공 한다. 

예를 들어, 

```py
list = ['kim', 'lee', 'park', 'kang']
```

위와 같은 원소를 가진 리스트에서 0번째 인덱스를 표현 하는 `list[0]`은 `kim`이다. 그리고 2번째 인덱스인 `list[2]`의 경우에는 `park`를 가르킨다. 

만약 위 원소들에 대해서 `list[0]`과 `list[2]`를 더하는 연산인 `+`을 수행하면 어떻게 될까? 

```py
print(list[0] + list[2])
```

그 결과는 `kimpark`를 출력 한다. 0분째 원소인 `kim`과 2번째 원소인 `park`를 붙여서 출력 하게 된다. 몰론 다른 자료형에서는 그에 맞는 연산을 수행 할 것 이다. 예를 들어 숫자로 이루어진 원소의 `+`연산일 경우 숫자의 합 결과를 출력 할 것 이다. 

그렇다면 리스트에서 마지막 원소를 얻는 방법은 무엇일까? 리스트의 길이를 알 수 없는 런타임 환경에서 어떻게 마지막 원소를 얻어서 사용 할 수 있을까? 
그 예제로 아래와 같은 코드와 그에 대한 결과를 보면 아래 내용들과 같다. 

```py
strList = ['kim', 'lee', 'park', 'kang']
print(strList[-1])
testList = [1, 4, 6, 12, 20]
print(testList[-1])
testList2 = [5, 6, 7, ['kang', 'lee']]
print(testList2[-1])
```

실행한 결과는 다음과 같다. 

```
kang
20
['kang', 'lee']
```

`[-1]`를 이용 하여 리스트의 마지막 원소에 접근 한다. 위의 코드와 그 결과를 통해 확인 할 수 있다. 리스트 안에 리스트가 존재 하는 `testList2`의 경우 마지막 원소로 존재 하는 리스트를 가져와 출력 하는 것 을 확인 할 수 있다. 

그렇다면 위와 같이 리스트내 리스트를 가져오고 그 리스트에 대한 인덱스의 처리를 간단히 하는 방법은 어떻게 할까? 그 방법은 아래와 같다. 

```py
print(testList2[-1][1])
```

실행한 결과는 `lee`를 출력 한다. `[-1]`을 이용 하여 마지막 원소 리스트에 접근 한 뒤 그 리스트에서 `[1]`번째의 인덱스 원소에 접근하여 출력하는 것 을 확인 할 수 있다. 몰론 이와 비슷한 방법으로 리스트가 여러개 중첩인 경우 비슷한 방식으로 접근 할 수 있다. 

## 1.2 리스트의 연산 처리 

### 1.2.1 리스트들을 더하거나 반복 하기 

주어진 리스트를 이용 하여 `+` 기호를 이용 하여 리스트 들을 합치는 기능을 수행 할 수 있으며, `*` 기호를 이용 하여 리스트를 반복 시킬 수 있다. 

```py
aList = [1, 2, 3, 4]
bList = [5, 6, 7, 8]

# 리스트 더하기
print(aList + bList)

# 리스트 반복
print(aList * 2)
print(bList * 3)
``` 

### 1.2.2 리스트 원소의 수정과 함수 사용방법 

- 리스트 원소의 수정 

리스트에 속해있는 원소를 수정하는 방법은 간단 하다. 해당 원소의 인덱스에 접근 하여 값을 대입 시켜 주면 된다. 

```py 
# 리스트에서 원소 수정 하기
elist = [3, 5, 6]
elist[1] = 100
print(elist)
```

위에서 `elist`리스트의 1번째 인덱스의 원소의 값을 `5`에서 `100`으로 변경 하였다. 출력한 그 결과는 `[3, 100, 6]` 이다.

- 리스트에서 여러개 원소의 수정 

리스트에 속한 연속되는 범위 내의 원소들을 모두 수정 하는 방법 이다. 

```py 
# 리스트에서 연속적 원소들을 수정 하기
elist = [4, 5, 6, 7]
elist[1:2] = ['a', 'b']
print(elist)
``` 

위에서 `elist`리스트에서 `1`번째 인덱스 부터 `2` 까지의 인덱스에 `['a', 'b']` 리스트를 대입 한다. 1번부터 2번까지 라는 것은 2번을 포함 하지 않는 1번째 인덱스를 뜻 한다. 그러므로 `elist`에서 1번째 인덱스인 `5`를 수정 한다. 

실행 한 결과는 `[4, 'a', 'b', 6, 7]` 이다. `5`원소를 대입 된 리스트로 변경되었음을 확인 할 수 있다. 

그렇다면 위와 동일 한 결과를 얻게 될 거라고 예측 되는 `elist` 리스트에서 1번째 인덱스에 직접적으로 위와 같이 배열을 대입 시켜서 수정 하면 어떻게 될까? 아래와 같은 소스를 실행 시켜 보자. 

```py
elist = [4, 5, 6, 7]
elist[1] = ['a', 'b']
print(elist)
```

위를 실행 시키면 `[4, ['a', 'b'], 6, 7]`의 결과를 얻을 수 있다. 1번째 인덱스의 값이 수정 되기는 했 지만 리스트가 그대로 대입 된 것을 확인 할 수 있다. 

리스트의 원소를 수정 하려 할때에는 조심히 접근 해야 한다. 특히 리스트원소에 다른 리스트를 대입 하여 수정 할 때에는 더 조심히 사용 해야 한다. 

- 리스트에서 원소들을 삭제 

리스트에서 특정 원소들을 일괄적으로 제거 할 때에는 아래와 같은 방법으로 제거 한다. 

```py
# 리스트에서 원소를 삭제 하기
elist = [4, 5, 6, 7, 8, 9]
elist[1:3] = []
print(elist)
```

`elist`에서 1번째 부터 3번째 인덱스 까지의 원소들에 비어있는 리스트인 `[]`를 대입 하여 삭제 한다. 결과는 `[4, 7, 8, 9]` 이다. 

- 리스트에서 하나의 원소를 삭제 

`del`이라는 함수를 이용 하여 리스트의 원소를 제거 한다. 사용법은 아래와 같다. 

```py
# 리스트에서 원소를 삭제
elist = [4, 5, 6, 7]
del elist[1]
print(elist)
```

`elist`에서 1번째 인덱스의 원소를 `del`함수를 이용 하여 제거 한다. 결과는 `[4, 6, 7]` 이다. 

- 리스트의 정렬 

리스트의 원소의 순서에 따라서 정렬을 하고 싶으면 리스트의 `sort()`함수를 이용 하여 정렬 한다. 이 정렬 방법은 숫자나 문자 모두 지원 된다. 사용 방법은 다음과 같다. 

```py 
# 리스트의 정렬
numList = [4, 2, 12, 8, 5, 1, 3]
numList.sort()
print(numList)

textList = ['r', 'Kim', 'jung', 'B', 'c', 'b', 'Zed', 'a']
textList.sort()
print(textList)
```

리스트를 만들고 리스트에 대해서 `.`을 이용 하여 `sort()`함수를 호출 하여 리스트를 정렬 시키고 있다. 지금은 오름차순만 정렬 하도록 한다. 결과는 아래와 같다. 

```
[1, 2, 3, 4, 5, 8, 12]
['B', 'Kim', 'Zed', 'a', 'b', 'c', 'jung', 'r']
``` 

- 리스트 뒤집기 

주어진 리스트를 `reverse()`함수를 이용 하여 역으로 뒤집는다. 이는 역순으로 정렬 하는게 아니라 주어진 원소들을 단순히 역으로 뒤집어 주는 것 뿐 이다. 
예제는 다음과 같다. 

```py 
# 리스트 뒤집기
elist = [1, 2, 3, 4]
elist.reverse()
print(elist)
```

결과는 `[4, 3, 2, 1]` 이다. 원소들이 역으로 뒤집힌 것을 확인 할 수 있다. 

- 리스트에서 원소를 찾고 존재시 인덱스를 얻기 

리스트에서 어떠한 원소가 있는지, 그리고 그 원소의 위치가 어디에 있는지 확인할 필요가 있다. 그 방법 으로는 `index()`라는 함수를 이용 하여 검색 한다. 

```py 
# 원소 탐색 하고 인덱스 얻기
elist = [11, 22, 33, 44]
print(elist.index(22))
slist = ['abc', 'kim', 'lee', 'park']
print(slist.index('abc'))
print(slist.index('zzzz'))      # 없을 경우
```

`index()`함수를 이용 하여 리스트의 원소를 찾고 그에 대해서 원소의 리스트내에서 인덱스 위치를 얻고 이를 출력 하는 소스 이다. 마지막 `index()`의 경우 일부로 틀린 값을 주어 리스트에서 존재 하지 않는 원소를 찾아보라고 한 경우도 있다. 이들의 결과는 다음과 같다. 

```
1
0
Traceback (most recent call last):
  File "studyList.py", line 75, in <module>
    print(slist.index('zzzz'))      # 없을 경우
ValueError: 'zzzz' is not in list
```

첫번째의 결과로 `22`를 찾는데 1번째 인덱스에 있으니 1을 반환 하여 출력 하였다. 두번째의 경우 `abc`라는 문자열을 찾는데 0번째 인덱스에 있기 때문에 0을 반환하여 출력 하였다. 

그러나 마지막 테스트 코드의 경우 문자열 리스트인 `slist`에 존재 하지 않는 `zzzz`라는 문자열을 검색 하니 오류가 발생 한다. `ValueError: zzzz is not in list` 라는 오류를 확인 할 수 있다. 그렇기 때문에 리스트에서 원소에 탐색은 조심히 사용 해야 한다. 

- 리스트에 원소를 원하는 위치에 추가 하기 

리스트에서 원소를 추가 하기 위해서는 `insert()`라는 함수를 이용 하여 삽입 한다. 이 함수에서 첫번째 패러미터로 사용 되는 값은 추가할 원소의 위치 인덱스 이며, 두번째 패러미터는 삽입할 값 이다. 예제 소스는 아래와 같다. 

```py
testlist = [1, 2, 3, 4, 5]
# 원소 삽입
testlist.insert(0, -1)  # 0번째 인덱스에 `-1`을 삽입
print(testlist)
testlist.insert(6, 999) # 6번째 인덱스에 `999`를 삽입
print(testlist)
testlist.insert(1000, 0)    # 1000번째 인덱스에 0 을 삽입 -> 마지막에 추가 된다 
print(testlist)
```

위의 소스를 실행 하면 아래와 같다. 

```
[-1, 1, 2, 3, 4, 5]
[-1, 1, 2, 3, 4, 5, 999]
[-1, 1, 2, 3, 4, 5, 999, 0]
```

지정한 인덱스에 값들이 삽입된 것을 확인 할 수 있다. 그 중 `1000`번째 인덱스에 원소를 삽입 하는 내용이 있다. 실제 리스트에서는 1000개째의 원소 인덱스가 없기 때문에 오류가 날 수 도 있을거라고 생각 했지만 리스트의 마지막 원소로 추가 되는 것 을 확인 할 수 있다. 

- 리스트에서 특정 원소를 제거 하기 

리스트에서 특정한 원소를 제거 하려면 `remove()` 함수를 사용 하면 되는데 특정한 원소를 탐색 하고 가장 먼저 발견되는 원소를 제거 하는 함수이다. 우선 예제 소스를 보도록 하자. 

```py 
testlist = [1, 2, 3, 1, 4, 5]
# 원소 제거
testlist.remove(1)  # `1` 라는 원소들 중 가장 먼저 찾는 원소를 제거
print(testlist)
testlist.remove(4)  # `4`라는 원소를 찾아서 제거
print(testlist)
# 찾아서 제거할 원소가 없을 경우 오류가 발생 한다.
```

위의 원소 중 `1`은 두개가 존재 한다. `remove(1)`함수를 이용 하여 `1`이라는 원소를 찾아 리스트에서 제거 한다. 아무튼 결과는 다음과 같다. 

```
[2, 3, 1, 4, 5]
[2, 3, 1, 5]
```

원소들 중에서 `1`을 가장 먼저 찾은 원소를 제거 한다. 결국 `0`번째 인덱스에 위치한 값을 제거 한 것 을 확인 할 수 있다. 

- 리스트에서 마지막 원소를 제거 하고 얻기 

`pop()`함수를 이용 하여 리스트의 원소들 중 가장 마지막 원소를 얻고 리스트에서 제거 한다. 

```py 
testlist = [1, 2, 3, 4, 5]
# 마지막 원소 얻고 제거
testlist.pop()
print(testlist)
element = testlist.pop()
print(testlist)
print(element)
```

실행결과는 다음과 같다. 

```
[1, 2, 3, 4]
[1, 2, 3]
4
```

`pop()` 함수는 리스트에 저장된 원소들 중 마지막 원소를 얻고 리스트에서 제거 한다. 그리고 `pop()`함수에서 반환되는 것은 리스트에서 `pop`연산 후에 얻게 되는 리스트에서 제거 될 마지막 원소 이다. 위 예제 소스에서 마지막 원소였던 `4`를 리스트에서 `pop`연산 하는 것 을 확인 할 수 있다. 

`pop`연산 이라는것은 `stack` 자료 구조에서 어떠한 특정 연산 이다. 이러한 것은 따로 공부 할 수 있다. 

- 리스트에서 특정 원소의 갯수 얻기 

주어진 리스트에서 특정한 원소가 존재 하면 `count()`함수를 이용 하여 해당 원소의 갯수를 얻는다. 주어지는 패러미터는 찾을 원소의  값 이다. 

```py 
testlist = [1, 2, 1, 3, 1, 4, 3, 5]
# 원소의 갯수 세기
print(testlist.count(1))
print(testlist.count(3))
print(testlist.count(5))
print(testlist.count(-1))
```

결과는 아래와 같다. 

```
3
2
1
0
``` 

주어진 패러미터의 값을 리스트에서 찾고 그 갯수가 몇개인지를 출력 하였다. 만약 찾는 원소가 리스트에 존재하지 않는다면 `0`을 반환 한다. 

- 리스트에 원소들이 존재 하는 리스트를 추가 하여 확장 하기 

`extend([리스트])` 함수를 이용 하여 리스트에 리스트를 추가 하여 확장 하듯이 사용 할 수 있다. 

```py 
# 리스트의 확장
testlist = [1, 2, 3]
extlist = [4, 5]
testlist.extend(extlist)
print(testlist)

testlist = [1, 2, 3]
extlist = [4, 5]
testlist += extlist   # testlist = testlist + extlist
print(testlist)

testlist = [1, 2, 3]
testlist.extend([4, 5])
print(testlist)
```

위의 실행 결과는 모두 동일 하다. 그 결과는 다음과 같다. 

```
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
```

- 리스트 원소의 갯수 얻기 

`len()`함수를 이용 하여 리스트 원소의 갯수를 얻는다. 

```py
scoreList = [32, 11, 94, 26, 86, 54, 62, 101, 80, 73]
print("%d" % len(scoreList))
```

실행 결과는 `10`이다. 이 함수는 나중에 공부 하게 될 튜플이나 문자열등에도 동일하게 사용 할 수 있다. 


## 2. 튜플 (Tuple)

튜플은 리스트와 동일하게 어떠한 데이터들의 선형적인 모음 이라고 할 수 있다. 예제로 다음과 같이 사용 한다. 

```py
t = (1, 2, 3, 4, 5)
print(t) 
```

실행 결과는 `(1, 2, 3, 4, 5)` 이다. 리스트와 사용 법이 거의 동일 하지만 원소들의 집합을 둘러 싸는 문자가 `[]`가 아니라 `()`임을 확인 할 수 있다. 그렇다면 리스트와 튜플은 비슷해 보이는데 왜 이렇게 다른 방식으로 구현 되며 이름까지도 다른 것 일까? 

- 리스트와 튜플의 다른 점 

리스트를 만들고 난 뒤에는 언제든지 원소들을 수정, 삭제, 추가 할 수 있다. 이렇게 수정이 계속 가능한 데이터 형을 `muttable (가변형)`이라고 한다. 

하지만 튜플 자료구조형은 리스트와는 다르게 최초에 생성한 원소들의 값을 수정 할 수 없다. 최초에 생성한 원소들의 목록 그대로 변하지 않고 사용 해야 한다. 이러한 데이터의 형태를 `immutable (불변형)`이라고 한다. JAVA언어에서 `String (immutable type)` 과 `StringBuilder`의 차이점을 알고 있다면 이해하기 쉽다. 

아래의 예제 소스를 보면 이해하기 더 쉽다. 

```py 
t1 = (1,)   # 단 한개의 원소만 가졌을 경우에도 ,를 붙인다
print(t1)

t = (1, 2, 3, 4, 5)
print(t)

t[2] = 100
print(t)        # 데이터를 수정 하려 하니 오류 발생 한다. 

del t[2]        # 원소 삭제 시도시 오류

tmp = (95, 96)
t += tmp        # append() 함수가 없음
print(t)

tstr = ("kang", "lee", "park", "kim", "lee", "jung")
print(tstr.index("park"))       # 2 출력 (2번째 인덱스에 위치)
print(tstr.count("lee"))        # `lee`라는 문자열이 2개 존재
print(tstr[2:])                 # `park` 부터 마지막 원소 까지 출력
``` 

리스트와 튜플 중에서 어떤 자료구조형을 사용 해야 하는가에 대해서 고민 할 경우에는 원소 데이터를 미리 다 알고 있거나 수정 할 일이 없는 경우에는 튜플을 사용 하고 그 외 모든 경우에는 리스트를 사용 하면 된다. 추 후 배울 딕셔너리도 고민 하면된다 하겠다. 

리스트와 동일 하게 `+` 연산이나 `*`은 동일 하다. 몰론 인덱싱을 이용 한 원소의 접근 과 잘라내는 것도 동일 하게 사용 하면 된다. 다만 튜플은 리스트와는 다르게 원소의 수정이나 삭제를 지원하지 않으므로 이에 대해서만 유의해서 사용 하면 된다. 

## 3. 딕셔너리 (Dictionarie) 

딕셔너리는 리스트와 튜플하고는 다른 구조를 갖고 있다. 리스트나 튜플 에서는 원소들의 집합 이었지만 딕셔너리의 경우에는 실제원소를 설명 하는 `Key`와 그에 해당 하는 값인 `Value`로 구분 된다. 

리스트나 튜플의 경우 순차적인 선형적 자료구조를 갖지만 딕셔너리는 key 를 이용 하여 value 를 얻는 구조 이다. 이는 사전과 비슷 하다고 할 수 있겠다. 사전에서 찾는 단어를 검색 하기 위해 앞글자를 찾던 것을 생각 해 보자. `hello`라는 단어를 사전에서는 찾기 위해서는 `h`라는 문자의 영역에 가야 한다. 여기에서 key 는 `h`이고 그 값은 `hello`라고 할 수 있겠다. 딕셔너리의 자료 구조는 이러한 `key-value`구조를 갖는다. 

이러한 key-value 자료구조는 리스트같은 선형구조와는 다른 장단점을 갖고 있다. 우선 그 장점중 하나로는 검색이나 탐색의 경우 일반 리스트보다는 훨씬 더 빠르다. 예를 들어 위에 설명한 `hello`라는 값을 찾기 위해서는 앞글자인 `h` 키만 검색 하고 그 키에 해당 하는 value 만 검색하면 되기 때문이다. 만약 선형적인 자료구조의 경우에는 0번째 인덱스 부터 어디에 존재하는지 알 수 없는 위치 까지 계속 검색 해야 하기 때문에 최악의 경우 느릴 수 밖에 없다. 

주의할 점은 딕셔너리에서 사용 되는 키 고유한 값으로서 중복되어 저장 할 수 없다. 또한 key 값은 변하지 않는 값(immutable) 이지만, 값은 변하는 값 (muttable)이나 변하지 않는 값 모두 사용 할 수 있다. 그리고 순서가 존재 하여 인덱스로 각 값을 구분하던 리스트나 튜플과는 달리 딕셔너리는 순서가 존재하지 않는다는 점을 기억 하자. 

그리고 딕셔너리 에서 중복되는 키의 값이 추가 된다면 키에 대해 단 한가지의 값만 사용 할 수 있는 성질에 의거 하여 단 하나의 값만 갖게 되고 나머지의 입력되는 키에 대한 값들은 모두 무시 된다. 이 점에 유의해서 사용 하도록 하자. 

- 딕셔너리의 기본 사용 예 

딕셔너리를 사용 할 때엔 `{}`문자로 둘러 싼 뒤 `{key : value}`의 구조를 갖는다. 그 예는 아래의 예제를 보면 알 수 있다. 

```py
dic = {'name':'Kang', 'email':'kang1010@google.com', 'phone':'01012345678'}
print(dic)
```

위와 같이 설정된 값은 다음과 같은 표로 표현할 수 있다. 

 key | value
 --- | --- 
 name | Kang 
 email | kang101@google.com 
 phone | 01012345678 

위 에서 정의한 key 값은 `name`, `email`, `phone` 이며, value 값은 `Kang`, `kang1010@google.com`, `01012345678` 이다. 

value 의 값에는 대부분의 자료형을 사용 할 수 있으며 심지어 리스트나 튜플의 자료형도 사용할 수 있다. 

- 딕셔너리에서 키와 값을 추가하기 

어떤 딕셔너리에 키와 값으로 이루어진 쌍을 추가 하는 방법은 다음과 같다. 어떠한 딕셔너리의 키를 정의 하고 `=`문자를 이용 하여 값을 정의 하면 된다. 아래 예제를 보도록 하자. 

```py 
dic = {'name':'Kang', 'email':'kang1010@google.com', 'phone':'01012345678'}
print(dic)
dic['gender'] = 'male'
print(dic)

nums = {1:'kang', 2:'lee', 3:'park'}
print(nums)
nums[4] = 'jang'
print(nums)
``` 

위 예제의 실행 결과는 다음과 같다. 

```
{'phone': '01012345678', 'email': 'kang1010@google.com', 'name': 'Kang'}
{'phone': '01012345678', 'email': 'kang1010@google.com', 'name': 'Kang', 'gender': 'male'}
{1: 'kang', 2: 'lee', 3: 'park'}
{1: 'kang', 2: 'lee', 3: 'park', 4: 'jang'}
```

예제와 같이 어떠한 키를 주고 그에 대한 값을 정의 하여 새로운 키-값 쌍을 추가 하는 것을 알 수 있다. 만약 키-값 쌍을 추가 할때 중복되는 키라면 오류가 발생 하는 것을 기억 하자. 

- 딕셔너리에 키와 값을 삭제 하기 

`del`함수를 이용 하여 키와 값을 제거 한다. 다음 예제 소스를 보자. 

```py 
dic = {'name':'Kang', 'email':'kang1010@google.com', 'phone':'01012345678'}
print(dic)
del dic['name']
print(dic)

nums = {1:'kang', 2:'lee', 3:'park'}
print(nums)
del nums[2]
print(nums)
```

예제 소스에 대한 실행 결과는 다음과 같다. 

```
{'email': 'kang1010@google.com', 'name': 'Kang', 'phone': '01012345678'}
{'email': 'kang1010@google.com', 'phone': '01012345678'}
{1: 'kang', 2: 'lee', 3: 'park'}
{1: 'kang', 3: 'park'}
```

- 딕셔너리에서 키를 검색 하여 값을 얻기 

리스트나 튜플에서 어떠한 원소에 접근하기 위해서는 인덱스를 이용 하여 원소에 접근 했었지만, 딕셔너리 에서는 어떠한 키 값을 이옹 하여 원소의 값에 접근 한다. 아래의 예제 소스를 보도록 하자. 

```py 
dic = {'name':'Kang', 'email':'kang1010@google.com', 'phone':'01012345678'}
print(dic['name'])
print(dic['phone'])

nums = {1:'kang', 2:'lee', 3:'park'}
print(nums[1])
print(nums[3])
```

실행 후 결과는 다음과 같다. 

```
Kang
01012345678
kang
park
```

예제에서 보듯이 어떠한 키 값으로 값을 얻어오는 것 을 확인 할 수 있다. 

- 닥셔너리에서 키 혹은 값들의 리스트 만들기 

딕셔너리에서는 여러개의 키와 값이 존재 할 수 있다. 이러한 키와 값의 목록을 따로 리스트로 받아서 사용 하기 위해서는 `keys()` 함수와 `values()` 함수를 사용 하면 된다. 이 함수들을 이용하면 리스트를 가진 특정 객체를 반환 받는데 이 객체를 이용 하여 리스트를 받을 수 있다. 

사용 예는 다음 예제 소스들을 확인 하자. 

```py 
# 키들의 리스트 만들기
dickeys = dic.keys()
print(dickeys)
dickeys = list(dic.keys())
print(dickeys)

# 값들의 리스트 만들기
dicvalues = dic.values()
print(dicvalues)
dicvalues = list(dic.values())
print(dicvalues)
``` 

실행 결과는 다음과 같다. 

```
dict_keys(['email', 'name', 'phone'])
['email', 'name', 'phone']
dict_values(['kang1010@google.com', 'Kang', '01012345678'])
['kang1010@google.com', 'Kang', '01012345678']
``` 

실행 결과에서 `dict_keys`와 `dict_values`가 등장함에 의아할 수 있는데 이것들은 각 `keys()` 함수와 `values()`함수에 의해서 리턴 된 각 객체들의 이름 이다. 반환된 객체들의 내부에 키와 값들의 리스트가 존재하는 것 이다. 

객체가 아닌 리스트로 바로 사용 하기 위해서는 `list()`를 이용 하여 리스트를 생성 하는것을 확인 할 수 있다. 그래서 keys() 함수와 values() 를 사용 하는것과 다름을 확인 할 수 있다. 

- 키와 값의 쌍을 튜플로 얻기 

주어진 딕셔너리에서 키와 값을 튜플로 생성한 값을 `dict_items`객체로 얻는 함수인 `items()`의 사용 예 이다. 

```py 
print(dic.items())
print(nums.items())
```

실행 결과는 다음과 같다. 

```
dict_items([('name', 'Kang'), ('phone', '01012345678'), ('email', 'kang1010@google.com')])
dict_items([(1, 'kang'), (2, 'lee'), (3, 'park')])
```

- 키로 값 얻기 

딕셔너리에서 키로 값을 검색해서 얻는 함수인 `get()`의 사용 예 이다. 이 함수는 `dic[keyname]`을 사용 한 것과 동일한 결과를 얻는다. 하지만 존재하지 않는 키로 탐색 시 오류를 발생 하는 것을 기억 하자. 만약 키가 없을 경우 미리 정해둔 default 값을 가져오기 위해서는 `get(keyname, defaultvalue)`와 같은 방법으로 두번째 패러미터에 default 값을 정의 하면 된다. 

예제 소스는 다음과 같다. 

```py 
print(dic.get('name'))
print(dic.get('phone'))
print(dic.get('address', 'not found'))
print(nums.get(1))
print(nums.get(3))
```

실행 결과는 다음과 같다. 

```
Kang
01012345678
not found
kang
park
```

`address`의 키 로 값을 검색시 값이 없으므로 미리 설정 해 둔 디폴트 값인 `not found`를 출력 함을 확인 할 수 있다. 

- 어떠한 키 가 딕셔너리에 존재하는지 확인 하기 

딕셔너리에서 찾는 키가 존재하는지 확인 하는 방법은 `in`함수를 이용 하여 참 과 거짓을 판별하여 사용 하면 된다. 예제 소스를 보도록 하자. 

```py 
print('name' in dic)
print('address' in dic)
print(1 in nums)
print(100 in nums)
```

실행한 결과는 다음과 같다. 

```
True
False
True
False
```
 
# 4. 셋 (Set)

집합 자료 구조인 Set 은 파이썬 2.3 부터 지원하는 어떠한 자료들의 집합을 처리하기 위한 자료 형 이다. 셋 자료형의 특징으로서는 중복을 허용하지 않으며, 원소들의 입력 순서가 존재하지 않는 다는 것 이다. 기존에 공부 한 리스트나 튜플의 경우 입력한 순서를 보장 받지만 셋 에서는 그 순서를 보장 하지 않는다. 그래서 인덱스가 의미가 없는데 이는 딕셔너리와 비슷 하다. 만약 인덱스를 통해서 원소에 접근하려면 리스트나 튜플로 변환해서 인덱스로 접근 하면 된다. 

보통 이러한 특징을 살려서 특정 자료들의 집합 에서 중복을 제거 하기 위한 용도로 사용 하기도 한다. 

```py 
s = set([1, 2, 3, 4])
print(s)

s = set("HelloWorld")
print(s)
```

실행 결과는 다음과 같다. 

```
{1, 2, 3, 4}
{'d', 'e', 'o', 'l', 'W', 'H', 'r'}
```

입력한 셋 중 두번째 `HelloWorld`를 셋으로 변환한 경우 중복되는 단어인 `l`은 셋 내부에서 단 하나만 존재 하는 것 을 확인 할 수 있다. 그리고 순서가 뒤죽박주으로 섞여있음도 확인 할 수 있다. 

- 셋들의 교집합, 합집합, 차집합 구하기 

셋들의 교집합, 합집합, 차집합은 각각에 해당하는 문자를 통해서 연산하거나 셋 고유의 함수를 이용 하여 처리 할 수 있다. 다음 예제소스들을 참고 하자. 

```py 
s1 = set([1, 2, 4, 5, 6])
s2 = set([2, 3, 4, 9, 7])

# 교집합
print(s1 & s2)
print(s1.intersection(s2))

# 합집합
print(s1 | s2)
print(s1.union(s2))

# 차집합
print(s1 - s2)
print(s1.difference(s2))
```

실행 결과는 다음과 같다. 

```
{2, 4}
{2, 4}
{1, 2, 3, 4, 5, 6, 7, 9}
{1, 2, 3, 4, 5, 6, 7, 9}
{1, 5, 6}
{1, 5, 6}
```

- 집합의 원소 삽입, 삭제 

집합에서 원소의 삽입, 삭제는 아래와 같이 함수를 이용 하여 이용 한다. 

```py 
s = set([1, 2, 3])
# 값 추가 하기
s.add(4)
s.add(5)
print(s)

# 값 여러개 추가 하기
s.update([7, 8, 9])
print(s)

# 특정 값 제거 하기
s.remove(3)
print(s)
```

실행결과는 다음과 같다. 

```
{1, 2, 3, 4, 5}
{1, 2, 3, 4, 5, 7, 8, 9}
{1, 2, 4, 5, 7, 8, 9}
```
