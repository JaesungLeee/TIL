## Kotlin을 이용한 앱 크래시 감소와 안정성 향상 

> 이 글은 Florina Muntenescu의 [Fewer crashes and more stability with Kotlin](https://medium.com/androiddevelopers/fewer-crashes-and-more-stability-with-kotlin-b606c6a6ac04)을 번역하였다.

사용자는 앱에 대해 원활히 사용할 수 있는 경험을 기대한다. 그래서 커뮤니티들의 의견을 보면 Kotlin을 선택하는 주 이유중 하나가 안전한 코드를 적용하기 위해서임을 이미 알고 있다. 이 게시글에서는 Kotlin이 일부 코드의 안정성을 개선하게 도와주는 몇가지 방법들을 공유 하며 Google play스토어 통계를 살펴보고 Kotlin사용간에 상관 관계가 있는지 확인 하려 한다. 

### 1. App quality

앱의 품질은 사용자 경험에만 영향을 미치는 것 은 아니다.많은 수의 앱 크래시로 인하여 영향을 받는 몇가지 다른 요소들이 있다:

- 앱의 노출 가능성 : Google play 스토어의 권장 사항은 인간 큐레이션(human curation)과 알고리즘의 조합으로 구성되며 앱의 품질이 큰 고려사항 중 하나가 된다. 
- 브랜드 : 제품의 성능은 평가 및 리뷰에 영향을 주게 되며 이는 사용자의 브랜드 인식에 영향을 줄 수 있다. 
- 더 많은 (참여)사용자 : 유기적인 트래픽과 브랜드 인지도를 개선하게 되면 사용자를 확보하고 유지하는데 도움이 되며, 이는 사용자의 참여도와 낮은 유입 경로 지표에도 영향을 끼칠 수 있다. 

> Kotlin으로 빌드 된 앱은 앱 크래시 가능성이 20% 더 낮다. 

Kotlin은 여기에서 어떤 역할을 해야 할까? Google play에서 상위 1,000개 앱을 살펴본 결과 Kotlin을 사용하는 앱은 그렇지 않은 앱 보다 사용자당 다운로드가 20%더 적음을 확인 할 수 있었다. 

이에 대한 예로, 전체 코드의 74%가 Kotlin인 Swiggy라는 앱의 엔지니어링 팀 에서 나왔다. 이 앱에서는 새로운 기능을 Kotlin으로 이전한 후 앱 크래시가 50%감소하였다. 

### 2. Avoiding NullPointerException

Google Play에서 앱 크래시의 가장 큰 원인은 `NullPointerException`(NPE)이다. 2018년에 Google Home팀은 Kotlin의 모든 새로운 기능을 작성하기 시작 했으며 1년 동안[NPE으로 인한 비정상 종료가 33% 감소](https://android-developers.googleblog.com/2020/07/Google-home-reduces-crashes.html) 하였다.

NPE를 방지하려면 런타임중 메소드를 호출하거나 해당 멤버 변수에 액세스 하기 전에 참조 객체가 null이 아닌지 확인 해야 한다. Kotlin에서 null의 허용 여부는 타입 시스템의 일부가 되어 있다. 예를 들어 Kotlin에서의 변수는 처음부터 nullable혹은 non-nullable인지 선언 되어야 한다. null허용 타입의 경우 메모리나 코드베이스에 대해 잘못된 혹은 위험한 접근을 할 경우 컴파일러에 의해 오류임을 알려 줄 것 이다.(`@Nullable`과 같은 어노테이션을 멤버 필드에 추가 했을때) 

null허용 객체에 대한 처리는 [이 글을](https://developer.android.com/topic/performance/vitals/crash#prevent-crashes-null-pointer)참고 하도록 하자. 

### 3. Avoiding common issue

개발자가 깨닫지 못한 채로 소개하는 많은 문제가 있을수 있으며 이러한 문제들이 매우 미묘하고 조사하기 어려울 수 도 있다. 아래는 Kotlin을 사용할 때 피할 수 있는 몇가지 문제들 이다. 

#### 3.1 `hashCode()` and `equals()`

두 객체가 같으면 해시코드또한 동일해야 하지만 이러한 메소드 중 하나를 구현하거나 새 속성이 클래스에 추가 될 때 이를 업데이트 하는 것을 잊어버릴 수 도 있다. 이럴 경우 데이터를 보관하는 역할을 하는 클래스로 적용하고 싶다면 Kotlin의 `data`클래스를 사용 하도록 한다. 데이터 클래스를 사용하면 `hashCode()`와 `equals()`등이 컴파일러에 의해 자동으로 생성되므로 클래스의 속성이 변경 된다면 자동으로 업데이트 된다. 

### 4. Structual vs Referential equality (구조적 vs 참조 비교)

두 객체가 구조적으로 같은지(동일한 내용을 갖고 있는지) 혹은 같은 참조를 하고 있는가?(참조 포인터가 같은지) 자바 에서는 원시 타입(Primitive type)의 경우 `==`를 사용 할 수 있었다. 그래서 발생할 수 있는 일반적인 실수가 참조 객체에 대해 `==`을 사용 하는 것 이다. 이 경우 객체간 참조를 비교하기 위해서는 `equals()`메소드를 사용해서 확인 해야 한다. 

첫번째로 Kotlin에서는 원시 타입(Primitive type)이 없으며 `Int`또는 `String`과 같은 클래스를 사용 한다. 즉, 모든 것이 하나의 객체이므로 더이상 객체와 원시 타입을 구분할 필요가 없다. 두번째로, Kotlin은 구조적 동등성에 대해 `==`를 사용 하고 참조가 같은지를 `===`를 사용함을 정의해 놓았기 때문에 쉽게 사용 할 수 있다. 

### 5. When if else if else if else is not enough (when-if-else 등의 반복이 더이상 필요하지 않다)

열거 형(Enum)으로 작업 할 때 가능한 모든 경우를 다루고 있는지 확인해야 할 필요가 있을 수 있다. 이로 인하여 switch혹은 if else반복이 사용 될 수 있다. 열거형에 새 값을 추가할 때 열거형을 사용중인 각 코드들은 수동으로 확인 해야 하며 모든 사례들을 실제로 처리 하고 있는지 확인 해야 한다. 그렇지만 이렇게 하는 경우 앞으로 오류가 발생할 확률이 높다. Kotlin에서 when을 표현식으로 사용하는 경우 컴파일러를 통해 모든 분기를 다루지 않으면 컴파일러 오류가 발생하기 떄문에 쉽게 확인 할 수 있다. 

### 6. 결론 

앱의 안정성은 결국 사용자와 그리고 브랜드에 중요한 역할을 한다. Kotlin을 사용하여 비정상인 앱의 크래시를 줄이고 사용자 만족도를 높이거나 유지하면서 높은 앱 평점을 얻으면 좋을 것 이다. 

