# 파이썬 기본기 익히기 네번째

## 1. 자료형 그리고 변수 

이전에 배운 자료형들에 대해서 조금 더 알아보고 자료형을 변수로 사용 하는 방법과 변수에 대한 기본 지식들을 살펴 보도록 하자. 

## 1.1 자료형의 `True`, `False`

자료형들의 참과 거짓을 판단 하는 방법은 조금씩 다르다. 그 판단 기준은 아래의 표와 같다. 

자료형 | 예시 값 | 결과 
--- | --- | --- 
문자열 | `"string"` | True 
문자열 | `""` | False 
리스트 | `[1, 2, 3, 4]` | True 
리스트 | `[]` | False 
튜플 | `()` | False 
딕셔너리 | `{}` | False 
숫자 | `n != 0` | True 
숫자 | `n == 0` | False 
숫자 | `None` | False 

문자열이나 리스트, 튜플 등 자료들의 모임 에서 원소가 하나도 존재 하지 않을 경우 `False`가 되는 것을 확인 할 수 있다. 이러한 참과 거짓에 대한 것은 반복문이나 제어문에서 흐름의 진행 여부를 판단하기 위한 조건의 검사에서 사용 된다. 위에서 자료 형이나 구조에 대해서 어떤 상황에 어떻게 판단을 해야 하는지를 잘 기억해 두자. 

## 1.2 변수 

지금까지 해 보면서 아래와 같은 구조를 많이 보았다. 

```py 
a = 10
b = 20
c = 30
```

위 소스에서 `=`기호에 의해 값이 대입된 `a`나 `b`, `c`같은 것을 **변수** 라고 부른다. 보통 `=`기호를 기준으로 좌측 문자를 변수에 사용될 이름 으로 정하고 우측 에 대입되는 것들이 변수에 대입되는 값 이다. 

여기에서 `a`의 예를 들어보면 `a`라는 변수는 메모리 어딘가에 저장된 10이라는 값을 가리키는 **포인터** 혹은 **레퍼런스**라고 할 수 있다. 어려운 메모리 접근을 간편하게 하기 위해서 변수를 이용해서 어떠한 값에 접근 하고 읽거나 쓰기를 한다. 

보통 다른 언어 에서 변수를 사용 하기 위해서는 아래와 같이 자료형을 명시 해 주어야 한다. 

```java 
int a = 10;
int b = 20;
int c = 30;
String str = "Hello World";
float value = 12.0f;
Object obj = new Object();
```

하지만 파이썬에서는 자료형을 따로 명시 하지 않아도 상관 없다.

또한 어떠한 변수와 다른 변수의 값이 같은지 여부를 판단 하는 방법은 아래와 같다. 

```py 
a = 10
b = 10
c = "Hell Korea"
d = "KangSungWoo"
e = b

print(a is b)	# true
print(a is c)	# false
print(b is a)	# true
print(c is d)	# false
print(e is b)	# true
```

위에서 `10`을 가진 변수는 총 3개 이다. `a, b, e`가 서로 다른 레퍼런스 변수 이지만 서로 같은 메모리를 가르키고 있다. 가르키고 있는 메모리의 주소는 동일 하기 때문에 `is`연산자를 사용하면 `True`를 얻는다. 

파이썬에서는 이런 경웅에서 10을 가르키고 있는 레퍼런스 변수가 몇개인지도 알 수 있다. 아래 예제를 보자. 

```py 
import sys
print(sys.getrefcount(10))	# 35
```

`sys`라는 공용 모듈을 임포트 한 뒤 `sys`에서 제공 하는 `getrefcount()`함수를 이용 하여 10이라는 값에 대한 레퍼런스의 갯수를 얻을 수 있다. 실행 하면 어떠한 수를 얻게 되는데 필자의 경우 35라는 수가 얻어졌다. 만약 추가적으로 이 값에 대해서 레퍼런스 변수가 생성 되면 이 수는 계속 늘어나게 된다. 


## 2. 함수 와 기본 구조 

파이썬에서 사용 되는 함수는 일반적인 것과 비슷 하니 설명은 넘어가고 사용 예를 보도록 하자. 

```py 
def 함수이름(인수1, 인수2, 인수3 ...):
    # 실행 내용 
    return 결과값
``` 

함수는 `def`라는 예약어를 통해서 정의 한다. 그리고 그 함수를 사용 하기 위한 이름을 정의 하고 인수들을 입력 받는다. 인수의 숫자는 제한이 없으며 자료형 또한 그렇다. 

그리고 실행한 처리의 결과를 `return`을 이용 하여 반환 한다. 만약 어떠한 함수를 호출 하여 인수를 전달 하고 난 뒤 그 결과를 받는 것이 `return` 이후의 결과 값을 통해서 전달 받게 되는 것이다. 몰론 이 값이 항상 필수는 아니다. 필요에 따라서 이 값이 존재 하지 않을 경우도 있으며 `None`같은 값으로도 대체 할 수 있다. 

함수의 사용예제를 보도록 하자. 

```py 
def sum(x, y):
	return x + y

print(sum(12, 34))
print(sum(100, 300))
```

`def` 예약어를 통해서 선언된 함수 `sum()`은 두개의 인수를 갖고 있다. 그 인수의 이름은 `x, y`로서 각 각 값을 입력 받는다. 그리고 `sum()`함수의 반환 값은 전달받은 `x`와 `y`을 더한 값을 반환 한다. 

`print()`함수를 통해서 `sum()`함수를 통해서 2번의 연산을 수행해 보았다. 첫번째로 12와 34의 합 이다. 문제없이 34의 값을 반환하고 출력 한다. 두번째 예제에서는 100과 300을 더해서 400이라는 값을 반환하고 출력 한다. 

함수를 잘 사용하게 되면 반복되는 소스 등을 정리 하여 함수로 정의 하여 재 사용 할 수 있다. 개발을 하면서 비용을 줄이기 위해서 잘 개발된 모듈을 만드는 것도 중요 한데 그 중에서는 잘 설계된 함수들도 한가지라고 할 수 있겠다. 

```py
def sumValue(x, y):
	if x <= 0 or y <= 0: return;
	return x + y

print(sumValue(10, 20))
print(sumValue(0, 50))
```

위 다른 형태의 예제에서는 위의 `sum()`함수와 동일한 작업을 수행 하지만 함수로 전달 받는 인수들인 `x`와 `y`의 값 들 중 하나라도 0보다 작거나 같다면 `return`을 통해서 함수를 빠져 나간다. `if`와 같은 제어문을 통해서 어떠한 전달받은 인수의 유효성을 검사하고 상황에 맞추어 함수를 빠져나가며 기본값이나 값을 비워 `None`으로 설정 할 수 도 있다. 
이런식으로 `return`을 통해서 함수를 빠져나가나는 연산은 생각보다 자주 사용 된다. 

위 예제에서는 인수가 존재하는 함수를 예제로 구현해 보았다. 하지만 인수가 없는 함수를 만들 수도 있지 않을까? 다음 예제를 확인 해보자. 

```py 
def createHelloWorld():
	return "HelloWorld"
print(createHelloWorld())
```

`createHelloWorld()`라는 함수는 `HelloWorld`라는 문자열을 반환 한다. 이 함수에서는 어떠한 인수도 받지 않고 그냥 문자열만 반환 하는 간단한 함수 이다. 

이번에는 인수들은 존재 하지만 반환 결과값이 없는 함수의 예제를 보도록 하자. 

```py 
def printHelloWorld(prefix, postfix):
	print(prefix + "Hello World" + postfix)
printHelloWorld("<<<", ">>>")
```

`printHelloWorld()`함수에서는 두개의 인수가 존재 한다. 하지만 반환하는 값은 없다. 하지만 함수 내부에서 `print()`함수를 호출 하여 입력된 인수들과 함께 `Hello World`문자열을 출력 한다. 위 예제의 결과 값은 `<<<Hello World>>>` 이다. 

이번에는 인수도 결과 반환값도 없는 함수의 예제 이다. 

```py 
def printLoveYou():
	print("I Love You")
printLoveYou()
```

인수도 없으며 반환하는 값도 없다. 다만 이 함수에서는 함수 내부에서 `print()`함수를 이용 하여 `I Love You`라는 문자열을 출력 한다. 

그렇다면 이번에는 인수가 많은 함수를 생각 해보자. 입력한 인수들을 모두 더해서 출력 하는 함수 이다. 예제를 보도록 하자. 

```py
def sumOfAllNumbers(a, b, c, d, e, f, g):
	return a+b+c+d+e+f+g
print(sumOfAllNumbers(1, 2, 3, 4, 5, 6, 7))
```

입력된 몇개의 숫자를 모두 더해서 반환하는 함수 이다. 이 함수의 예는 좋지만 너무 많은 인수로 인해서 다루기 까다로운 단점이 존재 한다. 이러한 함수의 인수가 많으면 많을 수록 유지 보수하기 더욱 더 까다로울 것 이다. 이번에는 다음의 예제를 보도록 하자. 

```py 
def sumOfAllNumbers(*nums):
	sum = 0
	for n in nums: sum += n
	return sum
print(sumOfAllNumbers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))
```

다시 재 정의 된 `sumOfAllNumbers()`함수에서는 특이 하게도 `*`문자를 결합한 `nums`라는 인수를 가족 있다. 그리고 함수 내부를 보면 마치 리스트나 튜플을 다루는 것 처럼 `for`반복문을 이용 하여 내부 원소애 접근 하여 `sum`이라는 값에 각 원소들을 더하고 더한 값을 마지막에 반환하는 것으 알 수 있다. 

위에서 `*nums`라는 것은 모든 입력된 인수들을 튜플로 만들어 준다. 이 인수들의 숫자는 제한이 없다. 예측 할 수 없는 인수를 가진 함수에서 이러한 인수를 다룰땐 위와 같이 다루면 된다. 

이번엔 다음 예제를 보도록 하자 

```py 
def sum(value, *nums):
	sum = value
	for n in nums: sum += n
	return sum
print(sum(10000, 10, 20, 30, 40, 50))
```

위 예제와 동일 하게 보이지만 인수에 `*`로 정의 된 인수와 그렇지 않은 인수가 함께 존재 할 수도 있음을 확인 할 수 있다. 

예제들을 보면 하나같이 동일 한 것을 알 수 있는데 그것은 **함수의 인수는 여러개 가 될 수 있지만, 결과값은 항상 하나 이다**라는 것 이다. 이 점을 기억 하면 된다. 

### 2.1 함수의 인수의 초기값 설정 

어떠한 함수로 전달받는 인수에 초기값을 설정 하는 방법을 알아 보자. 아래 예제 소스를 보도록 하자. 

```py 
def divideValues(x = 1, y = 1):
	return x / y

print(divideValues(200, 100))
print(divideValues(30))
print(divideValues())
```

어떠한 값 `x, y`를 입력받아 나누고 그 결과를 반환하는 함수르인 `divideValues()`가 있다. 여기에서 받는 인수는 두개 인데 이 두 인수에 대한 초기값을 설정해 주는 형태이다. 

위의 예제를 보면 첫번째 메소드에서는 `x`의 값에 200을, `y`의 값에 100을 대입 시켜 함수를 실행 한다. 두번쨰 에제에서는 함수로 전달하는 인수가 하나 뿐 이다. 이 상황에서는 `x`에 30이란 값이 대입 된다. 그리고 마지막 함수의 경우 인수가 존재하지 않음을 알 수 있다. 이 경우 `x`는 초기값인 1이 되고 `y`또한 초기값인 1이 된다. 

이 함수들을 실행 시킨 결과는 아래와 같다. 

```
2.0
30.0
1.0
```

마지막 함수의 경우 `1 / 1`의 결과인 1.0을 확인 할 수 있다. 

이렇게 초기값을 설정하는 함수는 편하게 사용할 수 있지만 조심해야 할 점이 있다. 다음의 예제 소스를 보자. 

```py 
def divideValues(x = 1, y):
	return x / y
```

위의 함수와 형태는 동일 하지만 두번째 인수인 `y`에 초기값을 대응 하지 않았다. 동일하게 실행 하려 하거나 IDE 등에서는 컴파일 오류인 `SyntaxError: non-default argument follows default argument`가 발생 한다. 

위의 경우 처럼 초기값을 대입한 함수의 인수의 다음 인수또한 초기값을 주어야 한다. 만약 그렇지 않다면 위의 경우 처럼 컴파일 오류가 발생한다는 점을 기억 하도록 하자. 

### 2.2 함수와 변수의 접근 범위 

우선 아래의 예제 소스를 보도록 하자. 

```py 
v = 10
def incrementValue(v):
	v += 20

incrementValue(v)
print(v)
```

`print()`함수를 통해서 출력 된 `v` 변수의 값은 어떨까? 10일까 아니면 30일까? 놀랍게도 그 결과는 10 이다. `incrementValue()`함수를 실행 시켜서 값을 증가시켰다고 생각됨에도 왜 값은 10이 되는 것 일까? 

위에서 함수 `incrementValue()`의 인자로 전달 받아 내부에서 사용 되는 변수 `v`는 외부에서 사용 되는 변수 `v`와는 다른 scope를 가지고 있다. 

외부에서 사용 되는 `v`와 함수 내부에서 사용 되는 `v`는 서로 다르다고 생각 하면 된다. 외부에서 사용 되는 `v`는 함수에 진입 할때 자신의 값을 복사한 새로운 함수 내에서만 사용 되는 인수 `v`를 생성 한다. 

## 3. 사용자 입력과 출력 

지금까지는 값을 개발자가 세팅하고 그 값을 가지고 하는 연산들을 주로 하였다. 그렇다면 이번에는 사용자가 직접 값을 입력하여 처리하는 방법에 대해서 알아보자. 그리고 출력하기 위해 사용 했었던 `print()`함수에 대해서도 조금 더 알아보자. 

### 3.1 사용자의 입력을 받는 함수 `input()`

`input()` 함수를 이용 하여 사용자의 입력을 받고 그에 대한 처리를 하는 방법에 대해서 알아 보자. 사용자의 입력을 받는 함수인 `input()`의 사용예제를 먼저 보자. 

```py 
inputValue = input()
print(inputValue)
```

위의 소스를 실행 시키면 아무런 내용이 출력되지 않는다. 하지만 커서가 깜밖거리면서 입력을 받기 위해서 대기중임을 알 수 있다. 여기에 어떠한 값을 입력 하면 입력한 값을 그대로 바로 출력 한 뒤 종료 한다. 

그런데 입력 받기 전에 커서만 깜박이니 뭘 입력해야 할지 모를때가 있다. 어떠한 가이드 메시지를 주려면 어떻게 해야 할까? 아래의 에제를 보도록 하자. 

```py 
scoreValue = input("점수를 입력해 주세요: ")
print("입력하신 점수는 %s 입니다." % scoreValue)
```

예제를 실행 시켜보면 커서 왼편에 `점수를 입력해 주세요: `가 출력 됨을 확인 할 수 있다. 이런식으로 사용자로부터 무엇을 입력할지에 대해서 가이드를 주어 원하는 데이터를 입력 받을 수 있다. 

그렇다면 어떠한 특정 입력이나 비어있는 입력 까지 무한으로 입력을 받게 하는 방법을 알아 보자. 

```py
while True:
	lineInput = input()
	if not lineInput: break
	print(lineInput)
```

`while`문을 입력 하여 무반 한복 을 하고 사용자가 입력한 내용이 `None`일 경우(입력을 하지 않은 경우) `break`를 통해서 반복을 중단 하는 형태 이다. 입력 한 내용이 존재 한다면 입력한 내용을 그대로 `print()`함수를 이용 하여 그대로 출력 한다. 비슷하지만 다른 형태인 다음 예제를 보자. 

```py 
result = ""
while True:
	lineInput = input()
	if not lineInput: break
	result += lineInput
print(result)
```

이전과 동일 하기는 하지만 `result`변수를 두고 입력한 내용을 이 변수에 계속 추가한 뒤 반복문을 빠져나가면 입력한 내용을 출력하는 방법이다. 

### 3.2 출력을 하는 함수 `print()`

`print()` 함수는 어떠한 것을 화면에 출력 해 주는 함수 이다. 일반적인 사용 예는 이미 많은 예제를 보았으니 잘 알고 있을거라 생각 된다. 그 외 다른 상황에서 출력 하는 방법에 대해서 알아보자. 

```py 
print("안녕", "하세요.", "반갑 습니다.", "좋은 하루 되세요")
# 출력 결과 : 안녕 하세요. 반갑 습니다. 좋은 하루 되세요
```

`print()` 함수 내부에서 `,`를 이용 하여 각 문자열을 구분 하면 각 문자열들을 공백(스페이스 문자) 로 구분하여 출력 해 준다. 

```py 
for i in range(5):
	print(i, end=" ")
# 출력 결과 : 0 1 2 3 4 	
```

`print()` 함수 에서 `end`변수를 두고 각 전달 받는 인수에 마지막 postfix 문자열을 붙일 수 있다. 위의 경우 `range()` 함수를 통해서 생성한 원소들의 목록을 이터레이션 하면서 각 원소에 접근하여 출력 하는데 원소마다 마지막 문자인 공백을 붙여서 출력 하게 해 주는 것이다. 그리고 출력되는 문자를 한줄로 출력 하게 해준다. 간단 하게 생각 해 보면 출력되는 어떠한 것들의 목록을 한 라인으로 출력 하는데 이 목록을 구분하기 위해서 `end`를 이용 하여 구분 하게 되는 것 이다. 

아래의 예제를 더 보도록 하자. 

```py 
users = {"kim", "jung", "park", "lee"}
for user in users:
	print(user, end=", ")
```

사람들의 정보로 이루어진 리스트 `users`의 사람들을 출력 하고 `,`로 구분하는 방법 이다. 이런 방식으로 각 구분자를 두고 한 라인에 출력 하는 방법을 사용 해 볼 수 있다. 	 

## 4. 파일 읽고 쓰기 

입력을 받기 위해서는 어떠한 변수에 값을 입력 하거나 사용자 입력을 `input()`함수 등을 통해서 받는 방식을 사용 했었다. 하지만 OS의 파일 시스템을 이용 하여 파일을 생성하고 쓰거나 읽는 등의 작업에 대해서 알아 보자. 

참고로 이 글 작성시 OS 는 OSX sierra 10.12.3 이다. 파이썬 3.4.3 으로 작업 하였다. 

### 4.1 파일 생성 하기 

파일을 생성 하거나 이미 생성된 파일을 사용 하기 위해서는 `open()`함수를 사용 한다. 아래의 예제를 보도록 하자. 

```py 
f = open('fileiostudy.txt', 'w')
f.close()
```

위 예제는 `open()`함수를 이용 하여 `fileiostudy.txt`라는 파일을 생성한다. `open()`함수의 사용 형태는 아래와 같다. 

```
파일객체 = open(파일의 이름, 파일 모드)
```
파일 객체는 추후 술명 하도록 하겠다. 파일의 이름은 생성할 파일이나 불러올 파일의 경로와 파일의 이름이라고 생각 하면된다. 실행한 `py`파일과 같은 경로라면 바로 파일의 이름을 위와 같이 작성 하면 되고 다른 경로에 있다면 절대경로나 상대경로를 작성 하면 된다. 상대 경로의 예 일 경우 아래 소스처럼 하면 된다. 

```py 
f = open('./study/fileiostudy.txt', 'w')
f.close()
```

osx에서 (혹은 유닉스 기반 OS) `.`은 실행된 프로젝트 나 `py`파일의 자기 자신의 경로를 뜻 한다. `py`파일이 포함된 경로내에 `study`디렉터리가 존재 한 다면 그 디렉터리 안에 `fileiostudy.txt`를 생성 할 것 이다. 

그 다음으로 파일 모드에 대해서 

mode | 설명 
--- | --- 
`r` | 읽기 모드 (기본) 
`r+` | 읽기 + 쓰기 모드 
`w` | 쓰기 모드 
`a` | 쓰기 + 이어 쓰기 모드 
`t` | 텍스트 모드 
`b` | 바이너리 모드 

파일을 쓰기 모드로 open할 때 정의한 파일이 존재 하지 않을 경우 생성 하지만, 이미 존재 할 경우 기존 내용이 사라지고 새로 작성 되어질 것 이다. 

파일 객체를 열고 난 뒤 파일을 대상으료 해야 할 작업들을 끝내면 `close()`는 될 수 있으면 해 주자. 몰론 파이썬에서 파일객체를 관리해주기 때문에 애플리케이션의 종료 시 자동으로 열려진 파일 객체를 닫아주지만, 쓰기 모드로 열었던 파일을 읽으려 시도 시 오류가 발생 하기 때문에 정확한 프로세스의 파일 읽기/쓰기를 보장 하고 싶다면 `close()`를 잘 활용하는 것이 좋다. 

### 4.2 파일 쓰기 

파일을 쓰기 위해서는 쓰기 모드인 `w`나 `r+`, `a`, `b`등의 모드를 이용해서 파일을 열고(`open()`) 작업 하면 된다. 파일에 내용을 작성 하려면 파일객체의 `write()`함수를 이용 해서 스트리밍 기법으로 작성 한다. 

`write()` 함수를 이용 해서 어떠한 출력값을 내보내면 라인별로 그 내용들이 파일에 작성 된다. 아래의 예제를 보도록 하자. 

```py 
f = open('./study/fileiostudy.txt', 'w')

f.write("Hello world\n")
for i in range(10):
	f.write("line : %d \n" % i)

f.close()
```

어떠한 경로에 있는 `fileiostudy.txt`을 쓰기모드(`w`)로 열고 어떠한 쓰기 작업을 수행 하였다. 작업 후 실행 결과인 `fileiostudy.txt`파일의 작성 내용을 보면 아래와 같다. 

```
Hello world
line : 0 
line : 1 
line : 2 
line : 3 
line : 4 
line : 5 
line : 6 
line : 7 
line : 8 
line : 9 
```
 
### 4.3 파일 읽기 

저장되어진 파일을 열고(`open()`) 내용을 읽기 위해서는 `read()`함수를 이용 해서 라인별로 읽는다. 아래 예제를 보도록 하자. 

```py 
filePath = "./study/fileiostudy.txt"

f = open(filePath, 'r')

readLine = f.readline()
print(readLine)

f.close()
```

이전 예제에 저장했던 파일을 다시 열고 라인 하나만 읽는 내용 이다. 출력 결과는 `Hello world` 이다. 이전 에제에서 파일에 저장했던 텍스트와 라인중 가장 첫번째 라인이 `Hello world`이기 때문에 해당 내용을 출력 하게 된다. 

이번에는 모든 내용을 읽고 출력 해 보자. 다음 예제를 보자. 

```py 
f = open(filePath, 'r')

while True:
	readLine = f.readline()
	if not readLine: break;
	print(readLine)

f.close()
```

무한 루프를 반복 하면서 `readLine()`을 통해서 라인별로 읽는다. 라인별로 읽었을때 읽은 결과가 존재 할경우에는 읽은 라인을 `print()`을 이용 하여 화면에 출력 한다. 하지만 `readLine()`한 결과가 없는 즉, 더이상 읽을 라인이 없어서 None일 경우 break문을 통해서 무한 루프를 중지 하게 된다. 

이번에는 이전과 동일 하기는 하지만 무한반복문을 사용하지 않는 방법이다. 

```py 
f = open(filePath, 'r')

readLines = f.readlines()
for line in readLines:
	print(line)

f.close()
```

이번에는 `readlines()`라는 함수를 이용 하여 읽을 파일의 라인별 읽은 내용을 리스트로 가져오는 방법이다. 

```py 
f = open(filePath, 'r')

reads = f.read()
print(reads)

f.close()
```

이번에는 `read()`라는 함수를 이용 하여 읽을 파일을 통째로 문자열로 읽고 이를 출력 하는 방법이다. 읽을 상대 파일을 감안하여 함수를 선택하여 읽고 사용 하면 된다. 

### 4.4 기존 파일에 쓰기 

파일 모드 중 `w`는 새로운 파일을 생성하고 작성할때만 쓰인다. 그렇기 때문에 기존에 생성된 파일의 내용에 이어 쓰기를 하려면 기존의 내용이 삭제 되어 버리기 때문에 적절하지 않다. 

기존에 만든 파일의 내용에 이어쓰기 위해서는 파일 모드를 `a`로 하여 파일을 열면(`open()`)하면 된다. 

```py 
f = open(filePath, 'a')
for i in range(500, 510):
	f.write("line : %d \n" % i)
f.close()
```

기존 쓰기 예제와 비슷해 보이지만 파일을 열때 `a`로 설정하고 파일을 여는것을 살펴 보자. 이 예제 소스실행 후 이어쓰기 한 파일의 내용은 아래와 같다. 

```
Hello world
line : 0 
line : 1 
line : 2 
line : 3 
line : 4 
line : 5 
line : 6 
line : 7 
line : 8 
line : 9 
line : 500 
line : 501 
line : 502 
line : 503 
line : 504 
line : 505 
line : 506 
line : 507 
line : 508 
line : 509 
```

`w`로 `open()`한 파일에 500부터 509까지 이어쓰기 한 내용을 확인 할 수 있다. 

### 4.5 `with`문 을 이용한 파일 읽기/쓰기 

위 예제들을 보면 항상 아래와 같은 형식을 갖는다. 

```py 
f = open("file.txt", "a")
f.write("Monty python's Flying Circus")
f.close()
```

만약 파일에 대한 읽기, 쓰기가 있을 때 마다 파일을 `open()`하고 `close()`하는 과정들이 반복 될 것 이다. 이부분을 `with`문을 활용 하여 `close()`를 작성하지 않아도 알아서 열린 파일을 닫을 수 있게 해 보자. 

```py 
with open(filePath, 'a') as f:
	f.write("Monty python's Flying Circus")
```

`with`문을 통해서 파일을 `f`라는 파일 객체 변수로 여는(`open()`)하는 데 `:` 이후 에서 실행 구문인 `write()`함수를 이용 해서 특정 문자열을 이어쓰기 하는 내용이다. 

풀어쓰면 이렇지만 바로 위 예제와 사실상 동일한 내용이다. 이렇게 `with`문을 사용 하면 직관적이고 간단하게 보일러 플레이트소스를 제거 할 수 있다. 