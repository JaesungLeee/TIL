# 파이썬 기본기 익히기 세번째 

## 1. `if-else` 문 

`if`와 `else`를 이용 하여 프로그래밍에서 조건을 보고 판단 하여 상황에 맞춘 분기를 해 보자. 

상황에 따라서 분기를 해야 하는 예를 말하면 이런 경우가 있을 것 이다. 어떠한 값이 `100`일 경우 100이 맞고 그 외에는 아니다 라고 출력 하는 프로그램이 있다. 이 경우 주어진 값이 `100`인지를 검사 하고 맞다면 그에 해당하는 상황을 출력 하고, 틀리다면 또 그에 해당하는 상황을 출력 해야 한다. 이를 정리 하면 다음과 같다. 

- 값을 입력 받는다. 
- 입력받은 값이 100이 맞다면 `값이 100이다` 를 출력 한다. 
- 입력받은 값이 100이 아니라면 `값이 1000이 아니다`를 출력 한다. 

위 상황을 코드로 구현해 보면 아래와 같다. 

```py
value = 90
if value == 100:
    print("값이 100 이다")
elif value == 90:
    print("값이 90 이다")
else:
    print("값이 100이 아니다")
```

주어진 값 변수인 `value`에서는 100으로 값을 초기화 한다. 그리고 `if` 문을 이용 하여 `value`변수의 값이 `100`인지 검사 한다. 맞다면 `값이 100 이다`를 출력 한다. 

만약 값이 `100`이 아니고 `90`일 경우에는 `elif`문에서 처리 하게 된다. 이 구문은 `else if`의 줄임이다. 

만약 주어진 값이 100이 아닌 모든 경우를 `else`문 아래에서 처리 하고 있다. 이 경우 `값이 100이 아니다`를 출력하고 있다. 

### 1.1. `if-else` 의 구조 

`if`와 `else`를 이용 하는 구조는 아래와 같다. 

```py 
# 기본 구조
if 조건문:
    실행_1
    실행_2
    ...
elif 조건문2:
    실행_1
    실행_2
    ...
else:
    실행_1
    실행_2
    ...
```

구조에서 보듯이 가장 중요 한 점은 `if`, `elif`, `else`로 이루어져 있으며 `:`과 들여쓰기를 통해서 조건문과 실행구문이 구분 된다. 조건에 해당하는 구문과 다른 일반적인 소스 라인의 구분에서 보통 다른 언어에서는 `{}`로 구분 하지만 파이썬에서는 **들여쓰기**로 구분 한다. 그 예로 다음 소스를 보자. 

```py
value = 100
if value == 100:
    print("값이 100 입니다. ")
  print("100을 입력하셨군요.")
else:
    print("값이 100이 아닙니다.")
```

소스에서 *4*번째 라인을 보면 기존 들여쓰기와는 다르다는것을 알 수 있다. 이런경우 실행 시키면 아래와 같은 오류가 발생 한다. 

```
  File ".../ifStudy.py", line 14
    print("100을 입력하셨군요.")
                         ^
IndentationError: unindent does not match any outer indentation level
```

`if-else`문을 이용 할때에는 들여쓰기가 매우 중요 하다. 보통 다른 언어에서는 들여쓰기에 대해서는 의존성이 없어 보통 들여쓰기에 사용 되는 문자를 `space`문자 나 `tab`문자를 사용 하는데 아무런 문제가 없지만 파이썬에서는 조금 신경 쓰이는 문제이다. 일반 적인 스페이스문자를 사용할 경우 백스페이스키를 잘못 눌러서 공간이 하나만이라도 줄어들면 컴파일이 안되는 문제가 발생 하기 때문이다. 

### 1.2 조건문의 구성 

조건문을 구성하는 방법에대해서 더 알아보자. 조건문에서 조건을 판단 하는 방법은 `True`와 `False`이다. 이는 일반적인 **참** 과 **거짓** 으로서, 이를 통해서 상황에 맞추어 분기 하는 것 이다. 아래 예제 소스를 보자. 

```py
intValueTrue = 10
intValueFalse = 0

if intValueTrue:
    print("주어진 값은 %d입니다." % intValueTrue)
if intValueFalse:
    print("주어진 값은 %d입니다." % intValueFalse)
if intValueTrue == 10:
    pass
elif intValueFalse == False:
    print("주어진 값은 거짓으로 판명된 %d입니다." % intValueFalse)
```

입력 받은 두개의 정수형 변수 `intValueTrue`와 `intValueFalse`가 있다. `pass`구문은 조건에 대해서 참 일경우 무시 하고 다음 조건문을 보거나 조건문을 빠져나가게 해 주는 것 이다. 

위 조건문들에 대한 결과는 아래와 같다. 

```
주어진 값은 10입니다.
주어진 값은 거짓으로 판명된 0입니다.
```

`intValueTrue`는 정상적으로 첫번째 조건문에서 값이 출력 되었다. 하지만 `intValueFalse`를 판단 하는 조건문에서는 2번째가 아니라 3번째로 갔다. 주어진 값은 `0`인데 왜 `False`로 판명이 난 것일까? 

파이썬에서는 어떠한 자료형에 대해서 참과 거짓의 판단을 자체적으로 하고 있다. 그 예는 아래 도표를 참고 해 보자. 

자료형 | `True` | `False` 
--- | --- | --- 
숫자 | 0 이 아닌 모든 숫자 | `0`
String | 길이가 0보다 큰 문자열 | `""` (길이가 0인 문자열)
List | 원소가 하나 이상 존재하는 리스트 | `[]` (원소가 없는 리스트)
Tuple | 원소가 하나 이상 존재하는 튜플 | `()` (원소가 없는 튜플) 
Dictionarie | 키-원소 쌍이 하나 이상 존재 하는 딕셔너리 | `{}` (키-원소 쌍이 없는 딕셔너리) 

### 1.3 비교 연산자 

조건이 참인지 거짓인지 판단 하기 위해서는 비교 연산자들을 사용 해서 구분 한다. 위 예제 소스에서 `==`와 같은 연산자들을 말한다. 아래 도표를 참고 하자. 

비교연산자 | 설명 
--- | --- 
`x < y` | `x` 값이 `y`보다 작다. 
`x > y` | `x` 값이 `y`보다 크다. 
`x == y` | `x` 값과 `y`이 같다. 
`x != y` | `x` 값과 `y`이 같지 않다. 
`x <= y` | `x` 값이 `y`와 같거나 작다. 
`x >= y` | `x` 값이 `y`와 같거나 크다. 

위 도표의 비교연산자를 활용한 조건문의 예는 아래와 같다. 

```py 
value = 120
if value == 120:
    print("값은 120 이다")
if value != 100:
    print("값은 100이 아니다")
if value > 100:
    print("값은 100보다 크다")
if value < 900:
    print("값은 900보다 작다")
if value >= 120:
    print("값은 120보다 같거나 크다")
if value <= 900:
    print("값은 900보다 같거나 작다")
```

실행 한 결과는 아래와 같다. 대부분의 상황이 `True`이기 때문에 모두 출력하는 것을 확인할 수 있다. 

```
값은 120 이다
값은 100이 아니다
값은 100보다 크다
값은 900보다 작다
값은 120보다 같거나 크다
값은 900보다 같거나 작다
```

간단한 예제를 해 보자. 

`만약 5000원 이상을 가지고 있다면 택시를 탄다. 하지만 5000을 갖지 못하고 2000을 갖고 있다면 지하철을 탄다. 그리고 그보다 더 적다면 그냥 걸어서 간다.`

위 예제를 소스로 작성 하면 아래와 같다. 

```py 
money = 5000
if money >= 5000:
    print("택시를 타고 가자!!")
elif money == 2000:
    print("지하철을 타고 가자!!")
elif money < 2000:
    print("걸어 가자..")
```

입력한 금액 변수인 `money`의 값에 따라서 분기가 달라질 것 이다. 

### 1.4 `and, or, not` 연산자 

다른 비교 연산자로서 `and`, `or`, `not` 이 있다. 이름에서 알 수 있듯이 양 변의 참 거짓을 확인 하는 연산자 이다. 

연산자 | 설명 
--- | --- 
`x and y` | x 와 y 둘 다 `True` 일 경우에만 `True`가 된다. 만약 둘중 하나라도 `False`가 있다면 `False`가 된다. 
`x or y` | x 와 y 둘 중 하나 이상이 `True` 일 때만 `True`가 된다. 하지만 둘 다 `False`라면 `False`가 된다. 
`not x` | x 가 `False`라면 `True` 이다. 

이는 예제소스를 보는게 더 빠르다. 

```py 
value = 100
strValue = ""
if value == 100 and value != 900:
	print("값은 정확히 100 이면서 900은 절대로 아니다.")
if value != 50 or value >= 100:
	print("값은 50이 아니거나 100보단 크거나 같다.")
if not value:
	print("값인 False(0)이 아니다.")
if not strValue:
	print("문자열이 현재 비어 있다.")
if not value == 900:
	print("값이 900 이 아니다.")
```

실행 결과는 다음과 같다. 

```
값은 정확히 100 이면서 900은 절대로 아니다.
값은 50이 아니거나 100보단 크거나 같다.
문자열이 현재 비어 있다.
값이 900 이 아니다.
```

첫번째 조건문은 `value == 100 and value != 900` 인데 `value`의 값이 100 이면서 900이 아니라는 것 이다. 두 조건을 모두 만족하는 조건 이기 때문에 `True`가 되어 실행구문을 실행 하여 결과를 출력 하는 것을 알 수 있다. 

두번째 조건문은 `value != 50 or value >= 100` 인데 `value`의 값이 50 이 아니거나 100보다 크거나 같다 이다. 첫번째 조건에는 해당하지 않지만 두번째 조건에 해당 하므로 실행 구문을 실행하여 결과를 출력 한다. 

세번째 조건에서는 `not value`인데 `value`가 `False`일 경우에 결과를 출력 한다. 하지만 `value`의 값은 100 이기 때문에 `True` 상태가 된다. 만약 0 이라면 `False`가 되기 때문에 실행 구문을 실행 하지만 지금의 경우 `True`이기 때문에 실행 구문을 실행 하지 않고 넘어 간다. 

네번째 조건에서는 `not strValue`인데 `strValue`라는 변수는 비어있는 문자열 이다. 이는 `False`상태 이기 때문에 조건에 대해서는 `True`상태가 되어 실행구문을 실행하여 결과를 출력 한다. 

다섯번째 조건에서는 `not value == 900`이다. 여기에서 `value`변수는 100 이라는 값 이기 때문에 조건문에 대해서는 `True`상태 가 된다. 그렇기 때문에 실행구문을 실행하여 결과를 출력 한다. 

### 1.5 `in, not in` 연산자 

`in`과 `not in` 비교 연산자는 어떠한 리스트나 튜플, 딕셔너리 와 같은 자료 구조에 원소로 존재 하는지 혹은 존재하지 않는지 확인 하는 연산자 이다. 사용 예는 아래 예제 소스를 확인 해 보자. 

```py 
print("1 은 [1, 2, 3] 리스트 안에 존재 하는가? %s " % (1 in [1, 2, 3]))
print("`A` 는 (`K`, `C`, `D`) 튜플 안에 존재 하는가? %s " % ('A' in ('K', 'C', 'D')))
print("500 은 [100, 200, 300] 리스트 안에 존재하지 않는가?  %s " % (500 not in [100, 200, 300]))
print("`Kang` 은 [`Kim`, `Kang`, `Jang`] 리스트 안에 존재하지 않는가? %s " % ("Kang" not in ["Kim", "Kang", "Jang"]))
print("'D'는 'PythonDjango 문자열에 존재 하는 문자인가? %s " % ('D' in "PythonDjango"))
```

실행 결과는 아래와 같다. 


```
1 은 [1, 2, 3] 리스트 안에 존재 하는가? True 
`A` 는 (`K`, `C`, `D`) 튜플 안에 존재 하는가? False 
500 은 [100, 200, 300] 리스트 안에 존재하지 않는가?  True 
`Kang` 은 [`Kim`, `Kang`, `Jang`] 리스트 안에 존재하지 않는가? False 
'D'는 'PythonDjango 문자열에 존재 하는 문자인가? True 
```

`in` 이나 `not in`의 뜻을 생각해 보면 간단 하다. 어떠한 리스트나 튜플 같은 자료 형에서 찾는 원소가 존재하는지 여부를 판단 하는 것 이다. 

첫번째 연산자의 경우 `1`이라는 숫자가 `1, 2, 3`이 존재 하는 리스트 내부에 원소로 존재하는지 확인 하는 것 이다. 실제로 원소가 리스트에 존재 하기 떄문에 `True`를 출력 하는 것 을 알 수 있다. 

두번째의 경우 `A` 라는 문자가 `K, C, D` 문자 들로 이루어진 튜플 안에 존재하는지 확인 한다. 이 튜플에는 `A`라는 문자가 없기 때문에 `False`를 출력 하는 것을 알 수 있다. 

마지막 연산의 경우 `PythonDjango`라는 문자열에서 `D`문자가 존재하는지 확인 하는 연산 이다. 실제로 `D`는 문자열 내에 존재 하기 때문에 `True`를 출력 한다. 

### 1.6 `if-else`를 한줄로 사용 해 보기 

하나의 조건문에 실행구문이 한줄로 존재 한다면 간단히 두 라인을 한 라인에 작성하여 사용 하는 방법이 있다. 아래 예제 소스를 보자. 

```py 
value = 10
if value == 10: print("값은 10 이다.")
else: print ("값은 10이 아니다")
```

`if`와 조건문, 그리고 실행 구문이 한 라인에서 사용 된 것을 확인 할 수 있다. 이렇게 작성 하는 경우 한눈에 조건에 해당하는 실행구문이 보이므로 편하게 느껴질 수도 있다. 

## 2. `while` 문

소스를 작성 하다 보면 어떠한 실행구간이 반복되는 경우가 있다. 이러한 반복 구간을 다루기 위해서는 반복제어문을 사용 하면 되는데 그 중 하나인 `while`문에 대해서 알아 보자. 

### 2.1 `while`문의 구조 

`while`문의 구조는 아래와 같이 간단 하다. 

```py
while 조건문:
    실행_1
    실행_2
    ...
``` 

구조에 대해서 설명 하면 이렇다. `while`문 과 `:` 사이의 조건문에서는 반복을 실행 하는지에 대한 여부인 `True`, `False`를 반환하는 조건 문이 들어간다. `if`문에서 사용 해본 조건 문과 동일 하다고 생각 하면 된다. 다음의 예제를 보자. 

```py
index = 1
while index <= 10:
	if index < 10:
		print("index 값은 %d 입니다." % index)
	else:
		print("index 값이 %d 입니다. 마지막 숫자 입니다." % index)
	index += 1
```

이 예제 소스의 실행 결과는 다음과 같다. 

```
index 값은 1 입니다.
index 값은 2 입니다.
index 값은 3 입니다.
index 값은 4 입니다.
index 값은 5 입니다.
index 값은 6 입니다.
index 값은 7 입니다.
index 값은 8 입니다.
index 값은 9 입니다.
index 값이 10 입니다. 마지막 숫자 입니다.
```

실행 후 초기 세팅 된 `index`의 값이 10보다 작거나 같을 때 까지 반복을 수행 한다. 수행할 반복의 내용은 `index`의 값이 10이 아닐 경우 어떠한 문자열을 출력 하지만 마지막 숫자인 10일 경우에는 마지막 숫자임을 알리고 종료 하는 소스 이다. `index`의 값은 한번 반복 할 때마다 값이 계속 증가 하는 `index += 1`에 조심 하자. 

이 예제의 실행 흐름을 정리하면 다음과 같다. 

index | 조건문 | 조건문에 대한 결과 | 출력되는 문자열 | `while`문의 상태 
--- | --- | --- | --- | --- 
1 | 1<=10 | `True` | index 값은 1 입니다. | 실행중 
2 | 2<=10 | `True` | index 값은 2 입니다. | 실행중 
3 | 3<=10 | `True` | index 값은 3 입니다. | 실행중 
4 | 4<=10 | `True` | index 값은 4 입니다. | 실행중 
5 | 5<=10 | `True` | index 값은 5 입니다. | 실행중 
6 | 6<=10 | `True` | index 값은 6 입니다. | 실행중 
7 | 7<=10 | `True` | index 값은 7 입니다. | 실행중 
8 | 8<=10 | `True` | index 값은 8 입니다. | 실행중 
9 | 9<=10 | `True` | index 값은 9 입니다. | 실행중 
10 | 10<=10 | `True` | index 값은 10 입니다. | 실행중 
11 | 11<=10 | `False` | "" | 반복 종료 

만약 이러한 소스를 `if-else`로 작성 하려면 최소한 11라인이 필요 하다. 하지만 `while`문 같은 반복제어문을 사용 하면 매우 간단하게 사용 할 수 있다. 

### 2.2 `continue` 와 `break` 

`while`반복문을 사용 하게 할 경우 특정 상황에 맞추어 반복을 멈추게 하거나 다음 반복문 흐름으로 강제로 넘기는 방법이 있다. 다음 예제 소스를 보자. 

```py 
index = 0
while index <= 10:
	if index == 2:
		index += 1
		continue 	# index 가 2일땐 index를 증가 시키고 다음 반복으로 진행
	elif index == 9:
		print("index 가 9일땐 강제 종료 합니다. ")
		break
	else:
		print("index 값은 %d 입니다." % index)
	index += 1
```

실행 결과는 다음과 같다. 

```
index 값은 0 입니다.
index 값은 1 입니다.
index 값은 3 입니다.
index 값은 4 입니다.
index 값은 5 입니다.
index 값은 6 입니다.
index 값은 7 입니다.
index 값은 8 입니다.
index 가 9일땐 강제 종료 합니다. 
```

실행 흐름을 정리 하면 다음과 같다. 

index | 조건문 | 조건문에 대한 결과 | 출력되는 문자열 | `while`문의 상태 
--- | --- | --- | --- | --- 
1 | 1<=10 | `True` | index 값은 1 입니다. | 실행중 
2 | 2<=10 | `True` | "" | 실행중 이지만 `index`만 1 증가시키고 다음 반복으로 `continue`
3 | 3<=10 | `True` | index 값은 3 입니다. | 실행중 
4 | 4<=10 | `True` | index 값은 4 입니다. | 실행중 
5 | 5<=10 | `True` | index 값은 5 입니다. | 실행중 
6 | 6<=10 | `True` | index 값은 6 입니다. | 실행중 
7 | 7<=10 | `True` | index 값은 7 입니다. | 실행중 
8 | 8<=10 | `True` | index 값은 8 입니다. | 실행중 
9 | 9<=10 | `True` | index 가 9일땐 강제 종료 합니다.  | `break`로 인해 문자열 출력 하고 반복 강제 종료 

`continue`제어문은 반복 중 어떤 특정 조건의 흐름에서 `continue`문을 만나기 전까지의 실행 구문만 실행하고 바로 다음 반복 흐름으로 넘어간다. `continue`문 전에 `index += 1`을 넣은 이유는 `continue`를 만날 경우 바로 다음 반복 흐름으로 넘어가는데 하단의 `index += 1`까지 실행 흐름이 가지 않기 때문에 `continue`문 전에 `index`만 1 증가 시키고 다음 흐름으로 넘어간 것 이다. 그렇기 때문에 아래에 존재 하는 출력실행을 하지 않고 넘어 간다. 

`break`제어문은 반복 중 어떤 특정 조건의 흐름에서 `break`문을 만나기 전까지의 실행 구문만 실행하고 반복을 강제로 종료 한다. 
`continue`와 `break`는 사용법은 같지만 기능은 완전히 서로 다르다. 그렇기 때문에 사용에 있어 주의를 요한다. 특히 이런 반복문에서 가장 조심해야 할 것은 **무한 반복**되는 경우 이다. 

### 2.3 무한 반복 

위에서 무한 반복에 대해서 조심해야 한다고 했었다. 하지만 어떤 반복을 무한으로 해놓고 특정 조건에 `break`문을 활용 하여 반복을 종료 시킨 다면 루틴을 문제 없이 잘 작성만 했다면 이러한 기법은 많이 사용되곤 한다. 다음 예제 소스를 보자. 

```py 
index = 1
while True:
	if index == 10:
		print("index 값은 10 입니다. 반복을 종료 합니다.")
		break
	print("index 값은 %d 입니다." % index)
	index += 1
```

실행 결과는 다음과 같다. 

```
index 값은 1 입니다.
index 값은 2 입니다.
index 값은 3 입니다.
index 값은 4 입니다.
index 값은 5 입니다.
index 값은 6 입니다.
index 값은 7 입니다.
index 값은 8 입니다.
index 값은 9 입니다.
index 값은 10 입니다. 반복을 종료 합니다.
```

자세히 보면 `while`문의 조건에 `True`만 들어가 있다. 이런 경우 조건문에 설정 된 `True`라는 값이 영원히 바뀌지 않기 때문에 이 반복문은 영원히 계속 반복 할 것이다. 이런 경우 문제가 발생 하고 실행되는 프로그램은 죽지 않고 계속 혼자서 실행 할 것이다. 이런 경우 CPU와 메모리의 자원을 계속 갉아먹기 떄문에 문제가 발생 한다. 

하지만 `break`문을 통해서 `index`값이 10일 경우 강제로 반복을 종료 하게 했다. 정확히 10번 반복 하고 종료 하는 것을 출력되는 문자열을 통해서 확인 할 수 있다. 

무한반복문은 몇번 반복될지 예측 불가능한 상황에서 특정 종료 시점에 대한 조건을 알고 있고 그게 명확하다면 문제 없이 사용 할 수 있다. 몰론 잘못된 루틴과 조건문으로 실행 하면 이러한 무한 반복은 말그대로 끝나지 않고 계속 혼자서 반복 할 것이다. 그렇기 떄문에 사용에 매우 주의를 요한다. 

## 2.4 `while`문을 중첩 하여 사용 하기 

`while`문을 2개 사용 하여 반복문 안에서 반복을 하게 되면 어떻게 될까. 다음 구구단을 계산하여 출력 하는 소스를 한번 보도록 하자. 

```py 
x = 1
y = 1
while x <= 9:
	if y == 10: y = 0
	while y <= 9:
		print("%d * %d = %d" % (x, y, x * y))
		y += 1
	x += 1
```

실행 결과는 다음과 같다. 일부 반복 되는 영역이 있어 생략 하였다. 

```
1 * 1 = 1
1 * 2 = 2
1 * 3 = 3
1 * 4 = 4
1 * 5 = 5
1 * 6 = 6
1 * 7 = 7
1 * 8 = 8
1 * 9 = 9
2 * 0 = 0
2 * 1 = 2
 ... 
8 * 9 = 72
9 * 0 = 0
9 * 1 = 9
9 * 2 = 18
9 * 3 = 27
9 * 4 = 36
9 * 5 = 45
9 * 6 = 54
9 * 7 = 63
9 * 8 = 72
9 * 9 = 81
```

편하게 **바깥 반복문** 과 **내부 반복문** 이렇게 구분 하도록 하겠다. 바깥 반복문 에서는 `x`의 값을 보며 내부 반복문 에서는 `y`의 값을 본다. 

바깥 반복문 에서는 `x`의 값이 9보다 작거나 같을때까지 반복 한다. 이때 x의 증가 시점은 내부 반복문이 종료 된 시점에 1씩 증가 된다. 

안쪽 반복문 에서는 `y`의 값이 9보다 작거나 같을때까지 반복 한다. 그리고 `x`와 `y`의 값을 곱하여 그 결과들을 출력 하고 `y`또한 1 증가 한다. 

안쪽 반복문에서 계속 값이 증가 하여 9보다 큰 10이 되었을 경우 안쪽 반복문은 종료 한다. 문제는 이값은 계속 10이기 때문에 다음 바깥 반복문의 다음 실행 흐름에서 이를 다시 0으로 초기화 시켜 준다. 그렇기 때문에 `y`값을 보는 안쪽 반복문이 실행 되게 되는 것 이다. 보기에는 복잡해 보이지만 이러한 형태의 소스를 많이 작성 해 보면 알 수 있다. 

반복문 하나를 사용 하는것은 나쁘진 않다. 실행 시간 과 메모리 사용량에 대해서 말이다. 조건문에서 `n`번까지 실행 하라 그러면 이 반복문의 실행 시간은 `n`만큼 일 것이며 메모리 사용량도 같다. 그보다 더 늦게 그리고 더 많은 메모리를 사용 하지 않는다. 하지만 반복문에 반복문을 중첩하면 이야기가 달라 진다. 

반복문 중첩의 경우 `n` 에서 `n`만큼 증가될 최악의 수가 생긴다. 이런 경우 `n`의 제곱수 까지 시간과 메모리를 점유 하기 때문에 `n`만큼만 반복 하는 것 보다 효율이 매우 좋지 않다. 이런 경우 알고리즘을 잘 고민 하여 반복문을 잘 제어 하는 기술이 필요한 것 이다. 

## 3. `for` 문

개발을 하다 보면 반복문을 생각보다 많이 사용 하게 된다. 게다가 여러 자료형의 원소들에 하나씩 접근 하여 처리 하거나 원소를 탐색 하는 등 을 처리 하기 위해서는 좀 더 직관적이고 간단한 반복문을 선호하게 된다. 그런 용도에서 `for`반복문은 매우 유용 하게 사용 할 수 있다. 

`for`문의 사용 예제를 보도록 하자. 

```py 
scoreList = [32, 11, 94, 26, 86, 54, 62, 80, 73]
for score in scoreList:
	print("점수는 %d 입니다." % score)
```

실행 결과는 다음과 같다. 

```
점수는 32 입니다.
점수는 11 입니다.
점수는 94 입니다.
점수는 26 입니다.
점수는 86 입니다.
점수는 54 입니다.
점수는 62 입니다.
점수는 80 입니다.
점수는 73 입니다.
```

첫번째 예제는 리스트 자료구조에서 어떤 원소들을 0번째 인덱스 부터 n번째 인덱스 까지 접근 하면서 일정한 포맷 문자열 형태로 출력 하는 방법 이다. 사용 방법은 간단 하다. `for`문 과 `in`을 이용 하여 변수 이름으로 정의 하고 리스트나 튜플, 문자열 등 선형적인 자료 구조에 접근 한다. 

```py 
for 변수이름 in 선형자료구조:
    실행코드
    ...
```

다음은 내부에 튜플을 갖는 리스트를 활용한 예제 이다. 

```py 
tupleList = [(5, 10), (80, 42), (22, 19)]
for (x, y) in tupleList:
	print("%d + %d = %d" % (x, y, x+y))
```

실행 결과는 다음과 같다. 

```
5 + 10 = 15
80 + 42 = 122
22 + 19 = 41
```

튜플을 원소로 가진 리스트 `tupleList`의 원소 튜플의 0번째 인덱스의 숫자와 1번째 인덱스 숫자를 각각 `for`문에서 `x`와 `y`의 정의된 변수로 숫자로 이루어진 튜플 자료구조인 `()`로 접근하여 사용 한다. 각각 정의된 변수를 통해서 실행코드 내에서 처리 하는 것을 볼 수 있다. 

이번에는 `if`문과 조합하여 반복과 제어를 통한 분기를 보도록 하자. 

```py 
scoreList = [32, 11, 94, 26, 86, 54, 62, 80, 73]
for score in scoreList:
	if score <= 60:
		print("점수 %d 는 불합격 입니다." % score)
	else:
		print("점수 %d 는 합격 입니다." % score)
```

이전에 사용 했던 점수로 이루어진 리스트을 대상으로 **60**점 보다 적거나 같으면 불합격, 그리고 60점을 초과하는 경우에는 합격 으로 분기하여 처리하는 소스의 예 이다. 실행 결과는 다음과 같다. 

```
점수 32 는 불합격 입니다.
점수 11 는 불합격 입니다.
점수 94 는 합격 입니다.
점수 26 는 불합격 입니다.
점수 86 는 합격 입니다.
점수 54 는 불합격 입니다.
점수 62 는 합격 입니다.
점수 80 는 합격 입니다.
점수 73 는 합격 입니다.
```

### 3.1 `for`문 에서 `continue`, `break` 

`while`문에서 사용 했었던 `continue`와 `break`문을 사용 할 수 있다. 아래의 예제 소스를 보도록 하자. 

```py 
scoreList = [32, 11, 94, 26, 86, 54, 62, 101, 80, 73]
for score in scoreList:
	if score <= 60:
		continue
	elif score > 100:
		print("오류!! 잘못된 점수인 %d 를 발견했습니다. 실행을 종료 합니다." % score)
		break
	else:
		print("점수 %d 는 합격 입니다." % score)
```

기존의 점수 목록 리스트 에서 `101`점이라는 나올 수 없는 점수를 중간에 추가 하였다. 이 코드의 실행 결과는 아래와 같다. 

```
점수 94 는 합격 입니다.
점수 86 는 합격 입니다.
점수 62 는 합격 입니다.
오류!! 잘못된 점수인 101 를 발견했습니다. 실행을 종료 합니다.
```

소스를 설명 하자면 점수 변수인 `score`로 대입된 리스트의 원소를 하나씩 꺼내서 보게 되는데 점수가 60점 이하인 경우 `continue`문에 의해 무시 하고 다음 반복문을 진행 한다. 이 경우 그래서 출력되지 않는다. 

점수가 100점을 초과하는 오류 상태일 경우 오류 메시지를 출력 하고 잘못된 점수까지 출력 해 준다. 그리고 `break`문을 이용 하여 강제로 반복문을 종료 한다. 이러한 기능은 `while`문과 동일하게 사용 할 수 있음을 알 수 있다. 

그리고 그외의 모든 경우에 대해서 점수를 정상적으로 출력 한다. 그래서 출력 결과에서는 60점보다 크고 100점보다 적은 값인 3개의 원소들만 출력 되고 101점이 원소였을때 종료 하기 때문에 그 이후 원소인 80과 73은 출력되지 않는다. 

이러한 점은 `while`문과 동일 하게 `continue`와 `break`를 사용 할 수 있음을 확인 할 수 있다. 

### 3.2 `range()`함수 

`range()`함수는 숫자로 이루어진 리스트를 자동으로 만들어 주는 함수 이다. 사용예는 다음과 같다. 

```py
# (0, 1, 2, 3, 4) 
intList = range(5)
for value in intList:
	print("%d" % value)

# (3, 4, 5, 6, 7)
intList = range(3, 8)
for value in intList:
	print("%d" % value)
```    

첫번째 예제의 경우 0부터 4까지의 원소를 만들어 준다. 파이썬에서 각 원소의 인덱스는 0부터 시작 하기 때문에 0부터 입력한 5의 전 값인 4 까지의 원소가 자동으로 생성된것을 확인 할 수 있다. 

두번째 예제의 경우 두개의 숫자 패러미터를 입력 하였는데 첫번째 패러미터 값에서 두번째 패러미터 값 까지의 숫자를 생성 해 준다. 이 에제에서는 첫번째 원소인 3부터 8의 전 값인 7 까지의 숫자를 생성하는 리스트 객체를 반환 한다. 

`range()`함수를 이용 하여 1부터 100 까지 더하는 것을 반복문을 이용 하여 사용할때 다음과 같이 할 수 있다. 

```py 
sum = 0;
for value in range(1, 101):
	sum += value
print("1 부터 100까지의 합은 %d 입니다." % sum)
```

`range()`함수를 이용 하여 1부터 100 까지 (101을 입력한 이유는 두번째 패러미터의 바로 전 값 까지 생성되기 때문이다) 더하고 그 결과를 출력 하는 것 이다. 실행 결과는 `1 부터 100까지의 합은 5050 입니다.` 이다. 

다음 예제로 `range()`함수를 이용 하여 구구단을 출력 해 보자. 구구단은 이전에 `while`문의 중첩을 이용 해서 출력 했었다. 이번에는 `for`문을 중첩하고 내부에 원소를 `range()`함수를 이용 하여 출력 하는 방법으로 해 보자. 

```py 
for x in range(2, 10):
	for y in range(1, 10):
		print("%d * %d = %d" % (x, y, x*y))
```

실행 결과는 다음과 같다. 반복되는 부분을 많이 생략 했다. 

```
2 * 1 = 2
2 * 2 = 4
2 * 3 = 6
2 * 4 = 8
2 * 5 = 10
2 * 6 = 12
2 * 7 = 14
2 * 8 = 16
2 * 9 = 18
3 * 1 = 3
 ...
8 * 9 = 72
9 * 1 = 9
9 * 2 = 18
9 * 3 = 27
9 * 4 = 36
9 * 5 = 45
9 * 6 = 54
9 * 7 = 63
9 * 8 = 72
9 * 9 = 81
```

### 3.3 리스트 안에 `for`문 사옹 하기 

리스트 안에 `for`문을 이용 하여 숫자를 세팅 하려 하는 예제를 보도록 하자. 

```py 
# 첫번째 예제 
value = []
for i in range(5):
	value.append(i * 2)
print(value)

# list comprehension 기법 을 사용 한 예제 
value = [i * 2 for i in range(5)]
print(value)
```

위 소스에서 첫번째 예제에서 `range()`함수를 이용 하여 0부터 4까지의 원소를 `value`라는 비어있던 리스트에 `i`로 대입 된 생성된 원소의 2에대한 곱의 결과를 `append()`함수를 이용 하여 추가 하는것을 알 수 있다. 아주 간단 한 예 이기는 하지만 한눈에 들어오는 초기화 과정은 아니다. 

다음 두번째 예제인 `list comprehension`를 사용 한 예를 보도록 하자. 첫번째 예제와 그 결과가 완전히 같다. 아래의 출력 결과물을 보도록 하자. 

```
[0, 2, 4, 6, 8]
[0, 2, 4, 6, 8]
```

`list comprehension`을 사용 하여 한눈에도 보이게 리스트내에 원소를 세팅 하는 과정을 볼 수 있다. 사용 문법은 아래와 같다. 

```py
리스트 = [대입변수의표현 for 대입변수 in (for문)(if문)]
```

다음 예제들을 더 보도록 하자. 

```py 
# list comprehension 두번째 예제 (0 부터 14까지 숫자들 중 짝수만)
value = [i for i in range(15) if i % 2 == 0]
print(value)

# 리스트 내 튜플의 list comprehension 세번째 예제 (n, n*n), ...
value = [(x, x*x) for x in range(5)]
print(value)
```

예제의 실행 결과는 다음과 같다. 

```
[0, 2, 4, 6, 8, 10, 12, 14]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16)]
```

새로운 예제의 첫번째 는 0부터 14의 숫자들 중 짝수만 리스트에 추가 하는 방법 이다. 리스트 내 `for`문 외에 `if`문을 이용 하여 원소의 추가에 제어를 하는 기법 이다. 

두번째 예제는 리스트 내에 튜플을 추가 할때 사용 하는 기법 이다. 내부에서 대입되는 변수의 표현 식 에서 `()`를 이용 하여 튜플로 저장 하고 튜플로 저장되는 원소 튜플의 1번째 인덱스의 값은 대입 변수인 `x`의 제곱을 추가하는 방법으로 사용 하고 있다. 

`list comprehension`는 기존 c나 자바 등에 익숙해져 있다면 낯설게 느껴지는 방법 이다. 하지만 익숙해지고 나면 쓸데 없는곳에 낭비 되거나 사실상 비슷한 보일러 플레이트 소스로 인한 낭비를 줄여주는 효과가 매우 크다. 파이썬을 공부 하는 보람이 느껴지는 기법 이라고 할 수 있겠다. 